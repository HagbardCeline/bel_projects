--! @file        prio_auto.vhd
--  DesignUnit   prio_auto
--! @author      M. Kreider <m.kreider@gsi.de>
--! @date        16/11/2015
--! @version     0.0.1
--! @copyright   2015 GSI Helmholtz Centre for Heavy Ion Research GmbH
--!

--! @brief AUTOGENERATED WISHBONE-SLAVE CORE FOR prio.vhd
--!
--------------------------------------------------------------------------------
--! This library is free software; you can redistribute it and/or
--! modify it under the terms of the GNU Lesser General Public
--! License as published by the Free Software Foundation; either
--! version 3 of the License, or (at your option) any later version.
--!
--! This library is distributed in the hope that it will be useful,
--! but WITHOUT ANY WARRANTY; without even the implied warranty of
--! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
--! Lesser General Public License for more details.
--!
--! You should have received a copy of the GNU Lesser General Public
--! License along with this library. If not, see <http://www.gnu.org/licenses/>.
--------------------------------------------------------------------------------

-- ***********************************************************
-- ** WARNING - THIS IS AUTO-GENERATED CODE! DO NOT MODIFY! **
-- ***********************************************************
--
-- If you want to change the interface,
-- modify prio.xml and re-run 'python wbgenplus.py prio.xml' !

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use work.wishbone_pkg.all;
use work.matrix_pkg.all;
use work.genram_pkg.all;
use work.prio_auto_pkg.all;

entity prio_auto is
generic(
   g_channels  : natural   := 16 --Input channels
);
Port(
   clk_sys_i         : std_logic;                                          -- Clock input for sys domain
   rst_sys_n_i       : std_logic;                                          -- Reset input (active low) for sys domain
   cnt_in_i          : in  matrix(g_channels-1 downto 0, 32-1 downto 0);   -- Incoming messages per Channel
   cnt_late_i        : in  std_logic_vector(32-1 downto 0);                -- Sum of all late messages
   cnt_out_i         : in  matrix(g_channels-1 downto 0, 32-1 downto 0);   -- Outgoing messages per Channel
   cnt_out_all_i     : in  std_logic_vector(64-1 downto 0);                -- Sum of all outgoing messages
   ctrl_stall_i      : in  std_logic_vector(1-1 downto 0);                 -- flow control
   st_full_i         : in  std_logic_vector(g_channels-1 downto 0);        -- Channel Full flag (n..0) 
   st_late_i         : in  std_logic_vector(1-1 downto 0);                 -- Late message detected
   ts_late_i         : in  std_logic_vector(64-1 downto 0);                -- First late Timestamp
   ch_sel_o          : out std_logic_vector(4-1 downto 0);                 -- Channel select
   clear_o           : out std_logic_vector(1-1 downto 0);                 -- Clears counters and status
   ebm_adr_o         : out std_logic_vector(32-1 downto 0);                -- Etherbone Master address
   eca_adr_o         : out std_logic_vector(32-1 downto 0);                -- Event Condition Action Unit address
   mode_o            : out std_logic_vector(3-1 downto 0);                 -- b2: Time limit, b1: Msg limit, b0 enable
   offs_late_o       : out std_logic_vector(64-1 downto 0);                -- Time offset before message is late
   reset_o           : out std_logic_vector(1-1 downto 0);                 -- Resets the Priority Queue
   tx_max_msgs_o     : out std_logic_vector(8-1 downto 0);                 -- Max msgs per packet
   tx_max_wait_o     : out std_logic_vector(32-1 downto 0);                -- Max wait time for non empty packet
   tx_rate_limit_o   : out std_logic_vector(32-1 downto 0);                -- Max msgs per milliseconds
   
   ctrl_i            : in  t_wishbone_slave_in;
   ctrl_o            : out t_wishbone_slave_out

   
);
end prio_auto;

architecture rtl of prio_auto is

   signal r_ctrl_stall     : std_logic_vector(1-1 downto 0);               -- flow control
   signal s_ctrl_stall_i   : std_logic_vector(1-1 downto 0);               -- flow control
   signal r_reset          : std_logic_vector(1-1 downto 0);               -- Resets the Priority Queue
   signal r_mode           : std_logic_vector(3-1 downto 0);               -- b2: Time limit, b1: Msg limit, b0 enable
   signal r_clear          : std_logic_vector(1-1 downto 0);               -- Clears counters and status
   signal r_st_full        : std_logic_vector(g_channels-1 downto 0);      -- Channel Full flag (n..0) 
   signal s_st_full_i      : std_logic_vector(g_channels-1 downto 0);      -- Channel Full flag (n..0) 
   signal r_st_late        : std_logic_vector(1-1 downto 0);               -- Late message detected
   signal s_st_late_i      : std_logic_vector(1-1 downto 0);               -- Late message detected
   signal r_ebm_adr        : std_logic_vector(32-1 downto 0);              -- Etherbone Master address
   signal r_eca_adr        : std_logic_vector(32-1 downto 0);              -- Event Condition Action Unit address
   signal r_tx_max_msgs    : std_logic_vector(8-1 downto 0);               -- Max msgs per packet
   signal r_tx_max_wait    : std_logic_vector(32-1 downto 0);              -- Max wait time for non empty packet
   signal r_tx_rate_limit  : std_logic_vector(32-1 downto 0);              -- Max msgs per milliseconds
   signal r_offs_late      : std_logic_vector(64-1 downto 0);              -- Time offset before message  is late
   signal r_cnt_late       : std_logic_vector(32-1 downto 0);              -- Sum of all late messages
   signal s_cnt_late_i     : std_logic_vector(32-1 downto 0);              -- Sum of all late messages
   signal r_ts_late        : std_logic_vector(64-1 downto 0);              -- First late Timestamp
   signal s_ts_late_i      : std_logic_vector(64-1 downto 0);              -- First late Timestamp
   signal r_cnt_out_all    : std_logic_vector(64-1 downto 0);              -- Sum of all outgoing messages
   signal s_cnt_out_all_i  : std_logic_vector(64-1 downto 0);              -- Sum of all outgoing messages
   signal r_ch_sel         : std_logic_vector(4-1 downto 0);               -- Channel select
   signal r_cnt_out        : matrix(g_channels-1 downto 0, 32-1 downto 0); -- Outgoing messages per Channel
   signal s_cnt_out_i      : matrix(g_channels-1 downto 0, 32-1 downto 0); -- Outgoing messages per Channel
   signal r_cnt_in         : matrix(g_channels-1 downto 0, 32-1 downto 0); -- Incoming messages per Channel
   signal s_cnt_in_i       : matrix(g_channels-1 downto 0, 32-1 downto 0); -- Incoming messages per Channel


begin

   s_ctrl_stall_i    <= ctrl_stall_i;
   ctrl_o.stall      <= r_ctrl_stall(0);
   reset_o           <= r_reset;
   mode_o            <= r_mode;
   clear_o           <= r_clear;
   s_st_full_i       <= st_full_i;
   s_st_late_i       <= st_late_i;
   ebm_adr_o         <= r_ebm_adr;
   eca_adr_o         <= r_eca_adr;
   tx_max_msgs_o     <= r_tx_max_msgs;
   tx_max_wait_o     <= r_tx_max_wait;
   tx_rate_limit_o   <= r_tx_rate_limit;
   offs_late_o       <= r_offs_late;
   s_cnt_late_i      <= cnt_late_i;
   s_ts_late_i       <= ts_late_i;
   s_cnt_out_all_i   <= cnt_out_all_i;
   ch_sel_o          <= r_ch_sel;
   s_cnt_out_i       <= cnt_out_i;
   s_cnt_in_i        <= cnt_in_i;
   ctrl : process(clk_sys_i)
      variable v_d : t_wishbone_data;
      variable v_a  : natural;
      variable v_p  : natural;
      variable v_s  : t_wishbone_byte_select;
      variable v_w  : std_logic;
      variable v_e  : std_logic;
   begin
      if rising_edge(clk_sys_i) then
         if(rst_sys_n_i = '0') then
            r_ctrl_stall      <= std_logic_vector(to_unsigned(0, 1));
            r_reset           <= (others => '0');
            r_mode            <= (others => '0');
            r_clear           <= (others => '0');
            r_st_full         <= (others => '0');
            r_st_late         <= (others => '0');
            r_ebm_adr         <= (others => '0');
            r_eca_adr         <= (others => '0');
            r_tx_max_msgs     <= (others => '0');
            r_tx_max_wait     <= (others => '0');
            r_tx_rate_limit   <= (others => '0');
            r_offs_late       <= (others => '0');
            r_cnt_late        <= (others => '0');
            r_ts_late         <= (others => '0');
            r_cnt_out_all     <= (others => '0');
            r_ch_sel          <= (others => '0');
            r_cnt_out         <= mrst(r_cnt_out);
            r_cnt_in          <= mrst(r_cnt_in);
         else
            ctrl_o.ack  <= '0';
            ctrl_o.err  <= '0';
            ctrl_o.dat  <= (others => '0');
         
            -- short names
            v_d := ctrl_i.dat;
            v_a := to_integer(unsigned(ctrl_i.adr(8 downto 2)) & "00");
            v_s := ctrl_i.sel;
            v_w := ctrl_i.we;
            v_e := ctrl_i.cyc and ctrl_i.stb and (not r_ctrl_stall(0));

            r_ctrl_stall   <= r_ctrl_stall and s_ctrl_stall_i; -- extend stall if requested by outer entity
            r_reset        <= (others => '0');
            r_clear        <= (others => '0');
            r_st_full      <= s_st_full_i;
            r_st_late      <= s_st_late_i;
            r_cnt_late     <= s_cnt_late_i;
            r_ts_late      <= s_ts_late_i;
            r_cnt_out_all  <= s_cnt_out_all_i;
            r_cnt_out      <= s_cnt_out_i;
            r_cnt_in       <= s_cnt_in_i;
            
            if(v_e = '1') then
               ctrl_o.ack  <= '1';
               if(v_w = '1') then
                  -- WISHBONE WRITE ACTIONS
                  case v_a is
                     when c_reset_OWR        => r_reset                    <= f_wb_wr(r_reset,                    v_d, v_s, "owr"); -- 
                     when c_mode_CLR         => r_mode                     <= f_wb_wr(r_mode,                     v_d, v_s, "clr"); -- 
                     when c_mode_SET         => r_mode                     <= f_wb_wr(r_mode,                     v_d, v_s, "set"); -- 
                     when c_clear_OWR        => r_clear                    <= f_wb_wr(r_clear,                    v_d, v_s, "owr"); -- 
                     when c_ebm_adr_RW       => r_ebm_adr                  <= f_wb_wr(r_ebm_adr,                  v_d, v_s, "owr"); -- 
                     when c_eca_adr_RW       => r_eca_adr                  <= f_wb_wr(r_eca_adr,                  v_d, v_s, "owr"); -- 
                     when c_tx_max_msgs_RW   => r_tx_max_msgs              <= f_wb_wr(r_tx_max_msgs,              v_d, v_s, "owr"); -- 
                     when c_tx_max_wait_RW   => r_tx_max_wait              <= f_wb_wr(r_tx_max_wait,              v_d, v_s, "owr"); -- 
                     when c_tx_rate_limit_RW => r_tx_rate_limit            <= f_wb_wr(r_tx_rate_limit,            v_d, v_s, "owr"); -- 
                     when c_offs_late_RW_0   => r_offs_late(31 downto 0)   <= f_wb_wr(r_offs_late(31 downto 0),   v_d, v_s, "owr"); -- 
                     when c_offs_late_RW_1   => r_offs_late(63 downto 32)  <= f_wb_wr(r_offs_late(63 downto 32),  v_d, v_s, "owr"); -- 
                     when c_ch_sel_RW        => r_ch_sel                   <= f_wb_wr(r_ch_sel,                   v_d, v_s, "owr"); -- 
                     when others => ctrl_o.ack <= '0'; ctrl_o.err <= '1';
                  end case;
               else
                  -- WISHBONE READ ACTIONS
                  case v_a is
                     when c_mode_GET            => ctrl_o.dat(2 downto 0)              <= r_mode;                       -- 
                     when c_st_full_GET         => ctrl_o.dat(g_channels-1 downto 0)   <= r_st_full;                    -- 
                     when c_st_late_GET         => ctrl_o.dat(0 downto 0)              <= r_st_late;                    -- 
                     when c_ebm_adr_RW          => ctrl_o.dat(31 downto 0)             <= r_ebm_adr;                    -- 
                     when c_eca_adr_RW          => ctrl_o.dat(31 downto 0)             <= r_eca_adr;                    -- 
                     when c_tx_max_msgs_RW      => ctrl_o.dat(7 downto 0)              <= r_tx_max_msgs;                -- 
                     when c_tx_max_wait_RW      => ctrl_o.dat(31 downto 0)             <= r_tx_max_wait;                -- 
                     when c_tx_rate_limit_RW    => ctrl_o.dat(31 downto 0)             <= r_tx_rate_limit;              -- 
                     when c_offs_late_RW_0      => ctrl_o.dat(31 downto 0)             <= r_offs_late(31 downto 0);     -- 
                     when c_offs_late_RW_1      => ctrl_o.dat(31 downto 0)             <= r_offs_late(63 downto 32);    -- 
                     when c_cnt_late_GET        => ctrl_o.dat(31 downto 0)             <= r_cnt_late;                   -- 
                     when c_ts_late_GET_0       => ctrl_o.dat(31 downto 0)             <= r_ts_late(31 downto 0);       -- 
                     when c_ts_late_GET_1       => ctrl_o.dat(31 downto 0)             <= r_ts_late(63 downto 32);      -- 
                     when c_cnt_out_all_GET_0   => ctrl_o.dat(31 downto 0)             <= r_cnt_out_all(31 downto 0);   -- 
                     when c_cnt_out_all_GET_1   => ctrl_o.dat(31 downto 0)             <= r_cnt_out_all(63 downto 32);  -- 
                     when c_ch_sel_RW           => ctrl_o.dat(3 downto 0)              <= r_ch_sel;                     -- 
                     when c_cnt_out_GET         => ctrl_o.dat(31 downto 0)             <= mget(r_cnt_out, v_p);         -- 
                     when c_cnt_in_GET          => ctrl_o.dat(31 downto 0)             <= mget(r_cnt_in, v_p);          -- 
                     when others => ctrl_o.ack <= '0'; ctrl_o.err <= '1';
                  end case;
               end if; -- v_w
            end if; -- v_e
         end if; -- rst
      end if; -- clk edge
   end process;

end rtl;
